<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R Arena - Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: #fafafa;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            margin: 0;
        }

        .container {
            background: white;
            border-radius: 24px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
            padding: 32px;
            max-width: 920px;
            width: 100%;
            border: 1px solid rgba(0,0,0,0.05);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #1a1a1a;
            font-size: 2rem;
            font-weight: 600;
            margin-bottom: 8px;
            letter-spacing: -0.02em;
        }

        .header p {
            color: #666;
            font-size: 0.95rem;
            font-weight: 400;
            margin: 4px 0;
        }

        .chart-container {
            position: relative;
            height: 500px;
            margin-bottom: 20px;
            background: #fdfdfd;
            border-radius: 16px;
            border: 1px solid #e5e7eb;
            cursor: crosshair;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .legend-color.original {
            background-color: rgba(0, 0, 0, 0.8);
        }

        .legend-color.mine {
            background-color: rgba(255, 0, 0, 0.8);
        }

        .legend-color.partner {
            background-color: rgba(0, 255, 0, 0.8);
        }

        .instructions {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
            color: #495057;
            text-align: center;
        }

        .mode-btn {
            margin: 0 4px;
            padding: 8px 16px;
            font-size: 13px;
            border-radius: 6px;
        }

        .mode-btn.active {
            background: #000;
            color: white;
        }

        .mode-btn.active:hover {
            background: #333;
        }

        @media (max-width: 768px) {
            .container {
                padding: 24px;
                margin: 0 16px;
            }
            
            .header h1 {
                font-size: 1.75rem;
            }
            
            .header p {
                font-size: 0.85rem;
            }
            
            .chart-container {
                height: 400px;
            }
            
            .legend {
                flex-wrap: wrap;
                gap: 12px;
            }
            
            .legend-item {
                font-size: 0.9rem;
            }
            
            .mode-btn {
                font-size: 12px;
                padding: 6px 12px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>R Arena</h1>
            <p>Room: <span id="roomId">-</span> | Players: <span id="playerCount">-</span></p>
            <p><strong>Turn: <span id="turnInfo">-</span> | Round: <span id="roundInfo">-</span></strong></p>
            <p><strong>Points left: <span id="pointsLeft">-</span></strong></p>
        </div>
        
        <div class="instructions">
            <div id="guessSection" style="margin-bottom: 15px; display: none;">
                <label for="correlationGuess">Guess the correlation (-1 to 1): </label>
                <input type="number" id="correlationGuess" min="-1" max="1" step="0.01" style="width: 100px; margin: 0 10px;">
                <button id="submitGuessBtn" class="btn mode-btn" onclick="submitGuess()">Submit Guess</button>
            </div>
            <div id="modeToggle" style="margin-bottom: 10px;">
                <button id="addModeBtn" class="btn mode-btn active" onclick="setMode('add')">Add Points</button>
                <button id="removeModeBtn" class="btn mode-btn secondary" onclick="setMode('remove')">Remove Points</button>
            </div>
            <div id="instructionText">Click anywhere on the plot to add points. Work with your partner to create interesting patterns!</div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color original"></div>
                <span>Original Points</span>
            </div>
            <div class="legend-item">
                <div class="legend-color mine"></div>
                <span>My Points</span>
            </div>
            <div class="legend-item">
                <div class="legend-color partner"></div>
                <span>Partner Points</span>
            </div>
        </div>

        <div class="chart-container">
            <canvas id="scatterChart"></canvas>
        </div>

    </div>

    <script>
        const initialPoints = 10
        let initialData = [];
        let addedData = [];
        let chart;
        let socket;
        let roomId;
        let targetCorrelation;
        let myPlayerIndex = -1;
        let currentTurn = 0;
        let pointsInCurrentTurn = 0;
        let maxPointsPerTurn = 3;
        let currentMode = 'add';
        let currentRound = 1;
        let maxRounds = 3;
        let gamePhase = 'guess'; // 'guess' or 'play'
        let userGuesses = [];
        let hasSubmittedGuess = false;

        function generateCorrelatedData(n, r) {
            const randn_bm = () => {
                let u = 0, v = 0;
                while(u === 0) u = Math.random();
                while(v === 0) v = Math.random();
                return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
            }

            const x_norm = Array.from({length: n}, () => randn_bm());
            const e_norm = Array.from({length: n}, () => randn_bm());

            const y_norm = x_norm.map((val, i) => r * val + Math.sqrt(1 - r*r) * e_norm[i]);

            const scale = (arr) => {
                const min = Math.min(...arr);
                const max = Math.max(...arr);
                const range = max - min;
                if (range === 0) return arr.map(() => 0);
                return arr.map(val => ((val - min) / range) * 190 - 95);
            };

            const scaledX = scale(x_norm);
            const scaledY = scale(y_norm);

            return scaledX.map((val, i) => ({x: val, y: scaledY[i]}));
        }

        function initChart() {
            const ctx = document.getElementById('scatterChart').getContext('2d');
            
            chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Original Points',
                        data: initialData,
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        borderColor: 'rgba(0, 0, 0, 1)',
                        borderWidth: 2,
                        pointRadius: 6,
                        pointHoverRadius: 8,
                        pointBackgroundColor: 'rgba(0, 0, 0, 0.9)',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2,
                        pointHoverBorderWidth: 3
                    }, {
                        label: 'My Points',
                        data: addedData,
                        backgroundColor: 'rgba(255, 0, 0, 0.8)',
                        borderColor: 'rgba(255, 0, 0, 1)',
                        borderWidth: 2,
                        pointRadius: 6,
                        pointHoverRadius: 8,
                        pointBackgroundColor: 'rgba(255, 0, 0, 0.9)',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2,
                        pointHoverBorderWidth: 3
                    }, {
                        label: 'Partner Points',
                        data: [],
                        backgroundColor: 'rgba(0, 255, 0, 0.8)',
                        borderColor: 'rgba(0, 255, 0, 1)',
                        borderWidth: 2,
                        pointRadius: 6,
                        pointHoverRadius: 8,
                        pointBackgroundColor: 'rgba(0, 255, 0, 0.9)',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2,
                        pointHoverBorderWidth: 3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: 'rgba(44, 62, 80, 0.9)',
                            titleColor: '#ffffff',
                            bodyColor: '#ffffff',
                            borderColor: '#667eea',
                            borderWidth: 1,
                            cornerRadius: 8,
                            displayColors: false,
                            callbacks: {
                                label: function(context) {
                                    return `Point: (${context.parsed.x.toFixed(2)}, ${context.parsed.y.toFixed(2)})`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            min: -100,
                            max: 100,
                            
                            ticks: {
                                color: '#7f8c8d',
                                font: {
                                    size: 12
                                }
                            },
                            grid: {
                                color: 'rgba(127, 140, 141, 0.2)',
                                lineWidth: 1
                            },
                            border: {
                                color: '#2c3e50',
                                width: 2
                            }
                        },
                        y: {
                            min: -100,
                            max: 100,
                            
                            ticks: {
                                color: '#7f8c8d',
                                font: {
                                    size: 12
                                }
                            },
                            grid: {
                                color: 'rgba(127, 140, 141, 0.2)',
                                lineWidth: 1
                            },
                            border: {
                                color: '#2c3e50',
                                width: 2
                            }
                        }
                    },
                    onClick: (event, elements) => {
                        if (!hasSubmittedGuess) {
                            alert('Please submit your correlation guess first!');
                            console.log('Current game phase:', gamePhase, 'Has submitted guess:', hasSubmittedGuess);
                            return;
                        }
                        
                        if (!canPerformAction()) {
                            if (gamePhase !== 'play') {
                                alert('Game phase is not active!');
                            } else {
                                alert(currentTurn === myPlayerIndex ? 
                                    'You\'ve reached your turn limit! Wait for your partner.' : 
                                    'It\'s not your turn!');
                            }
                            return;
                        }

                        if (currentMode === 'remove' && elements.length > 0) {
                            const element = elements[0];
                            const datasetIndex = element.datasetIndex;
                            const pointIndex = element.index;
                            
                            removePoint(datasetIndex, pointIndex);
                            if (socket && roomId) {
                                console.log('Emitting remove-point:', { roomId, datasetIndex, pointIndex });
                                socket.emit('remove-point', { roomId, datasetIndex, pointIndex });
                                
                                // Optimistically update turn state (will be corrected by server if needed)
                                pointsInCurrentTurn++;
                                updateTurnDisplay();
                            }
                        } else if (currentMode === 'add') {
                            const rect = chart.canvas.getBoundingClientRect();
                            const x = event.clientX - rect.left;
                            const y = event.clientY - rect.top;
                            
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chart);
                            const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
                            const dataY = chart.scales.y.getValueForPixel(canvasPosition.y);
                            
                            if (dataX >= -100 && dataX <= 100 && dataY >= -100 && dataY <= 100) {
                                addPoint(dataX, dataY);
                                if (socket && roomId) {
                                    console.log('Emitting add-point:', { roomId, x: dataX, y: dataY });
                                    socket.emit('add-point', { roomId, x: dataX, y: dataY });
                                    
                                    // Optimistically update turn state (will be corrected by server if needed)
                                    pointsInCurrentTurn++;
                                    updateTurnDisplay();
                                }
                            }
                        }
                    },
                    onHover: (event, elements) => {
                        chart.canvas.style.cursor = elements.length > 0 ? 'pointer' : 'crosshair';
                    }
                }
            });
        }

        function addPoint(x, y) {
            addedData.push({x: x, y: y});
            chart.update();
            updateStats();
        }

        function addPartnerPoint(x, y) {
            chart.data.datasets[2].data.push({x: x, y: y});
            chart.update();
            updateStats();
        }

        function calculateCorrelation(data) {
            if (data.length < 2) {
                return 0;
            }

            const xValues = data.map(p => p.x);
            const yValues = data.map(p => p.y);

            const n = data.length;
            const sumX = xValues.reduce((a, b) => a + b, 0);
            const sumY = yValues.reduce((a, b) => a + b, 0);
            const sumXY = data.reduce((acc, p) => acc + p.x * p.y, 0);
            const sumX2 = xValues.reduce((acc, val) => acc + val * val, 0);
            const sumY2 = yValues.reduce((acc, val) => acc + val * val, 0);

            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

            if (denominator === 0) {
                return 0;
            }

            return numerator / denominator;
        }

        function updateStats() {
            // No longer display correlation - it's hidden during gameplay
            return;
        }

        function updateTurnDisplay() {
            const isMyTurn = currentTurn === myPlayerIndex;
            const pointsLeft = maxPointsPerTurn - pointsInCurrentTurn;
            
            document.getElementById('turnInfo').textContent = isMyTurn ? 'Your turn' : 'Partner\'s turn';
            document.getElementById('roundInfo').textContent = `${currentRound}/${maxRounds}`;
            document.getElementById('pointsLeft').textContent = isMyTurn ? pointsLeft : '-';
            
            // Update turn info color
            const turnElement = document.getElementById('turnInfo');
            turnElement.style.color = isMyTurn ? '#2ecc71' : '#e74c3c';
            
            // Show/hide guess section based on game phase
            const guessSection = document.getElementById('guessSection');
            if (gamePhase === 'guess' && isMyTurn && !hasSubmittedGuess) {
                guessSection.style.display = 'block';
            } else {
                guessSection.style.display = 'none';
            }
        }

        function canPerformAction() {
            // Player can act if:
            // 1. They have submitted their guess for this round (hasSubmittedGuess = true)
            // 2. It's their turn
            // 3. They haven't exceeded their move limit
            return hasSubmittedGuess && currentTurn === myPlayerIndex && pointsInCurrentTurn < maxPointsPerTurn;
        }

        function setMode(mode) {
            currentMode = mode;
            const addBtn = document.getElementById('addModeBtn');
            const removeBtn = document.getElementById('removeModeBtn');
            const instructionText = document.getElementById('instructionText');
            
            if (mode === 'add') {
                addBtn.classList.add('active');
                addBtn.classList.remove('secondary');
                removeBtn.classList.remove('active');
                removeBtn.classList.add('secondary');
                instructionText.textContent = 'Click anywhere on the plot to add points. Work with your partner to create interesting patterns!';
            } else {
                removeBtn.classList.add('active');
                removeBtn.classList.remove('secondary');
                addBtn.classList.remove('active');
                addBtn.classList.add('secondary');
                instructionText.textContent = 'Click on any point to remove it. This counts toward your turn limit!';
            }
        }

        function removePoint(datasetIndex, pointIndex) {
            if (datasetIndex === 0) {
                initialData.splice(pointIndex, 1);
            } else if (datasetIndex === 1) {
                addedData.splice(pointIndex, 1);
            } else if (datasetIndex === 2) {
                chart.data.datasets[2].data.splice(pointIndex, 1);
            }
            chart.update();
            updateStats();
        }

        function removePartnerPoint(datasetIndex, pointIndex) {
            if (datasetIndex === 0) {
                initialData.splice(pointIndex, 1);
            } else if (datasetIndex === 1) {
                chart.data.datasets[1].data.splice(pointIndex, 1);
            } else if (datasetIndex === 2) {
                chart.data.datasets[2].data.splice(pointIndex, 1);
            }
            chart.update();
            updateStats();
        }

        function initializeGame() {
            const urlParams = new URLSearchParams(window.location.search);
            roomId = urlParams.get('room');
            targetCorrelation = parseFloat(urlParams.get('correlation'));
            const initialDataParam = urlParams.get('initialData');
            myPlayerIndex = parseInt(urlParams.get('playerIndex') || '-1');
            currentTurn = parseInt(urlParams.get('currentTurn') || '0');
            pointsInCurrentTurn = parseInt(urlParams.get('pointsInCurrentTurn') || '0');
            maxPointsPerTurn = parseInt(urlParams.get('maxPointsPerTurn') || '3');
            currentRound = parseInt(urlParams.get('currentRound') || '1');
            gamePhase = urlParams.get('gamePhase') || 'guess';
            
            console.log('Initialized game with phase:', gamePhase, 'round:', currentRound, 'player:', myPlayerIndex);
            
            if (!roomId || isNaN(targetCorrelation) || myPlayerIndex === -1) {
                window.location.href = '/welcome.html';
                return;
            }
            
            document.getElementById('roomId').textContent = roomId;
            document.getElementById('playerCount').textContent = '2';
            
            if (initialDataParam) {
                try {
                    initialData = JSON.parse(decodeURIComponent(initialDataParam));
                } catch (e) {
                    console.error('Error parsing initial data:', e);
                    initialData = generateCorrelatedData(initialPoints, targetCorrelation);
                }
            } else {
                initialData = generateCorrelatedData(initialPoints, targetCorrelation);
            }
            
            initChart();
            updateStats();
            updateTurnDisplay();
            
            socket = io();
            
            socket.on('connect', () => {
                console.log('Socket connected, joining room:', roomId, 'as player', myPlayerIndex);
                socket.emit('join-room', { roomId: roomId, playerIndex: myPlayerIndex });
            });
            
            socket.on('point-added', (point) => {
                console.log('Received point-added event:', point);
                
                // Only process points from partner, not own points
                if (point.userId !== socket.id) {
                    console.log('Adding partner point:', point);
                    addPartnerPoint(point.x, point.y);
                }
                
                // Update turn info if included
                if (point.currentTurn !== undefined) {
                    currentTurn = point.currentTurn;
                    pointsInCurrentTurn = point.pointsInCurrentTurn;
                    updateTurnDisplay();
                }
            });

            socket.on('point-removed', (data) => {
                console.log('Received point-removed event:', data);
                
                // Only process point removals from partner, not own removals
                if (data.userId !== socket.id) {
                    console.log('Removing partner point:', data);
                    removePartnerPoint(data.datasetIndex, data.pointIndex);
                }
                
                // Update turn info if included
                if (data.currentTurn !== undefined) {
                    currentTurn = data.currentTurn;
                    pointsInCurrentTurn = data.pointsInCurrentTurn;
                    updateTurnDisplay();
                }
            });

            socket.on('turn-changed', (turnData) => {
                console.log('Turn changed:', turnData);
                currentTurn = turnData.currentTurn;
                pointsInCurrentTurn = turnData.pointsInCurrentTurn;
                updateTurnDisplay();
            });
            
            socket.on('guess-submitted', (data) => {
                console.log('Guess submitted by player:', data);
                console.log('My player index:', myPlayerIndex, 'Has submitted guess:', hasSubmittedGuess);
                // Partner submitted their guess
                if (data.playerIndex !== myPlayerIndex && hasSubmittedGuess) {
                    // Both players have submitted guesses, start the round
                    console.log('Both players have submitted guesses, starting play phase');
                    gamePhase = 'play';
                    updateTurnDisplay();
                }
            });
            
            socket.on('round-start', (data) => {
                console.log('Round starting:', data);
                gamePhase = 'play';
                updateTurnDisplay();
            });
            
            socket.on('new-round', (data) => {
                console.log('New round started:', data);
                currentRound = data.currentRound;
                gamePhase = data.gamePhase;
                currentTurn = data.currentTurn;
                hasSubmittedGuess = false;
                pointsInCurrentTurn = 0;
                
                // Re-enable guess input for new round
                document.getElementById('correlationGuess').disabled = false;
                document.getElementById('submitGuessBtn').disabled = false;
                document.getElementById('correlationGuess').value = '';
                
                console.log(`Starting round ${currentRound}, reset to guess phase`);
                updateTurnDisplay();
            });
            
            socket.on('game-over', (data) => {
                console.log('Game over:', data);
                alert(`Game Over!\n\nFinal Scores:\nPlayer 1 Average Error: ${data.player1AvgError.toFixed(4)}\nPlayer 2 Average Error: ${data.player2AvgError.toFixed(4)}\n\nWinner: Player ${data.winner}`);
                window.location.href = '/welcome.html';
            });

            socket.on('turn-error', (error) => {
                console.log('Turn error:', error);
                alert(error.message);
            });
            
            socket.on('user-disconnected', () => {
                alert('Your partner has disconnected. Returning to lobby...');
                window.location.href = '/welcome.html';
            });
        }

        function submitGuess() {
            const guessInput = document.getElementById('correlationGuess');
            const guess = parseFloat(guessInput.value);
            
            if (isNaN(guess) || guess < -1 || guess > 1) {
                alert('Please enter a valid correlation between -1 and 1');
                return;
            }
            
            hasSubmittedGuess = true;
            
            if (socket && roomId) {
                socket.emit('submit-guess', { roomId, guess, playerIndex: myPlayerIndex });
            }
            
            updateTurnDisplay();
            guessInput.disabled = true;
            document.getElementById('submitGuessBtn').disabled = true;
            
            console.log('Submitted guess for round', currentRound);
        }
        
        function startGameRound() {
            gamePhase = 'play';
            console.log('Game phase set to play');
            updateTurnDisplay();
        }
        
        
        function endGame() {
            if (socket && roomId) {
                socket.emit('end-game', { roomId });
            }
        }

        window.addEventListener('load', initializeGame);
    </script>
</body>
</html>